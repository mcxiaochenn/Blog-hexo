---
title: 记录一次博客评论差点全丢的事（原因+解决思路及方法）
abbrlink: cb573663
tags:
  - 教程
  - 博客维护
  - 实战
categories:
  - 教程
  - 博客折腾
cover: https://bu.dusays.com/2025/08/20/68a5bef47327b.webp
summary: >-
  这里是小尘AI，这篇文章记录了作者因修改Hexo的abbrlink插件配置（从crc16改为crc32并添加前缀p）导致博客评论链接错误而几乎丢失所有评论的经历。起因是插件默认生成纯数字链接引发功能异常，修改后意外影响了旧文章的链接结构。作者通过Navicat连接MongoDB，学习SQL语法并编写脚本批量更新评论的url和href字段，高效解决了问题，强调了数据备份和操作谨慎的重要性。
date: 2025-08-20 20:07:47
---

## 起因

我使用abbrlink插件默认参数设置发现有概率为文章生成纯数字链接，例如``abbrlink: 114514``，这会导致部分功能异常。

于是按照ai说的把abbrlink插件配置由：
```yml
permalink: posts/:abbrlink/
# 一个 Hexo 插件，用于根据帖子正面的标题和数据生成静态帖子链接。
# https://github.com/rozbo/hexo-abbrlink
# abbrlink config
abbrlink:
  alg: crc16      #support crc16(default) and crc32
  rep: hex        #support dec(default) and hex
  drafts: false   #(true)处理草稿，(false)不处理草稿。false（默认值）
  # 从目录树生成类别
  # 深度：要生成的目录树的最大深度应大于0
  auto_category:
    enable: true  #true(default)
    depth:        #3(default)
    over_write: false 
  auto_title: false #启用自动标题，可以按路径自动填充标题
  auto_date: false #启用自动日期，它可以自动填写日期的时间今天
  force: false #启用强制模式，在这种模式下，插件将忽略缓存，并为每个帖子计算abbrlink，即使它已经有了abbrlink。
```
改成了：
```yml
permalink: posts/p:abbrlink/
# 一个 Hexo 插件，用于根据帖子正面的标题和数据生成静态帖子链接。
# https://github.com/rozbo/hexo-abbrlink
# abbrlink config
abbrlink:
  alg: crc32      #support crc16(default) and crc32
  rep: hex        #support dec(default) and hex
  drafts: false   #(true)处理草稿，(false)不处理草稿。false（默认值）
  # 从目录树生成类别
  # 深度：要生成的目录树的最大深度应大于0
  auto_category:
    enable: true  #true(default)
    depth:        #3(default)
    over_write: false 
  auto_title: false #启用自动标题，可以按路径自动填充标题
  auto_date: false #启用自动日期，它可以自动填写日期的时间今天
  force: false #启用强制模式，在这种模式下，插件将忽略缓存，并为每个帖子计算abbrlink，即使它已经有了abbrlink。
```

这样如此链接就不可能是纯数字，ai还说老文章不受影响，我就放心改完上传了。让我没想到的是它会在老文章参数的基础上加上个p！！！进而引发了这场惨案。

## 发现

我一开始并没有发现，高高兴兴把昼夜切换按钮的bug修了，后面测试移动端排版的时候瞥了一眼评论区。我擦！我评论咋全没了，然后就开始排查，发现是这个问题。

## 解决

于是我用[Navicat](https://www.navicat.com.cn/)连上了MangoDB，手动修改。

之后觉得效率太低了，去学习了下SQL查询的语法（技能+1）

写了个简易脚本：

```js
var oldSlug = "pe9";    // 替换前
var newSlug = "p7e9";   // 替换后

db.comment.updateMany(
  { 
    $or: [
      { url: { $regex: "/posts/" + oldSlug } },
      { href: { $regex: "/posts/" + oldSlug } }
    ]
  },
  [
    {
      $set: {
        url: { $replaceOne: { input: "$url", find: "/posts/" + oldSlug, replacement: "/posts/" + newSlug } },
        href: { $replaceOne: { input: "$href", find: "/posts/" + oldSlug, replacement: "/posts/" + newSlug } }
      }
    }
  ]
)
```

替换效率更高一点，同一篇文档下所有评论都可以一键替换，还好我文章发的不多，除去学习发现时间，替换就花了5分钟的样子，完美解决。

## 尾声

数据无价心莫轻，链接改动慢思量，评论全失才明白，操作谨慎方安康。